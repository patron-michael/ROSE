```{r init, prompt=FALSE, echo=FALSE}
# Install development branch
#remotes::install_github("patron-michael/ROSE@dev_merge")
#detach("package:ROSE", unload = TRUE)
library(ROSE)
data(hacide)

library(knitr)
library(rmarkdown)
```

## Initial implementation

```{r standart workflow, prompt=FALSE, echo=FALSE}
# unbalance on training set
table(hacide.train$cls)
#unbalance on test set
table(hacide.test$cls)

# plot unbalanced data highlighting the majority and 
# minority class examples.
par(mfrow=c(1,2))
plot(hacide.train[, 2:3], main="Unbalanced data", xlim=c(-4,4),
     ylim=c(-4,4), col=as.numeric(hacide.train$cls), pch=20)
legend("topleft", c("Majority class","Minority class"), pch=20, col=1:2)

# model estimation using logistic regression
fit <- glm(cls~., data=hacide.train, family="binomial")
# prediction using test set
pred <- predict(fit, newdata=hacide.test)
roc.curve(hacide.test$cls, pred,
          main="ROC curve \n (Half circle depleted data)")

# generating data according to ROSE: p=0.5 as default
data.rose <- ROSE(formula =  cls~., data=hacide.train, seed=3)$data
table(data.rose$cls)

par(mfrow=c(1,2))
# plot new data generated by ROSE highlighting the 
# majority and minority class examples.
plot(data.rose[, 2:3], main="Balanced data by ROSE",
     xlim=c(-6,6), ylim=c(-6,6), col=as.numeric(data.rose$cls), pch=20)
legend("topleft", c("Majority class","Minority class"), pch=20, col=1:2)

fit.rose <- glm(cls~., data=data.rose, family="binomial")
pred.rose <- predict(fit.rose, data=data.rose, type="response")
roc.curve(data.rose$cls, pred.rose, 
          main="ROC curve \n (Half circle depleted data balanced by ROSE)")
par(mfrow=c(1,1))

```

## Second implementation

```{r standart workflow, prompt=FALSE, echo=FALSE}
# unbalance on training set
table(hacide.train$cls)
#unbalance on test set
table(hacide.test$cls)

# plot unbalanced data highlighting the majority and 
# minority class examples.
par(mfrow=c(1,2))
plot(hacide.train[, 2:3], main="Unbalanced data", xlim=c(-4,4),
     ylim=c(-4,4), col=as.numeric(hacide.train$cls), pch=20)
legend("topleft", c("Majority class","Minority class"), pch=20, col=1:2)

# model estimation using logistic regression
fit <- glm(cls~., data=hacide.train, family="binomial")
# prediction using test set
pred <- predict(fit, newdata=hacide.test)
roc.curve(hacide.test$cls, pred,
          main="ROC curve \n (Half circle depleted data)")

predictor_vars <- names(hacide.train[, !colnames(hacide.train) %in% c("cls")])
response_var <- names(hacide.train["cls"])

# Print the extracted variables
print(response_var)
print(predictor_vars)

# generating data according to ROSE: p=0.5 as default
data.rose <- ROSE(response_var, predictor_vars, data=hacide.train, seed=3)$data
table(data.rose$cls)

par(mfrow=c(1,2))
# plot new data generated by ROSE highlighting the 
# majority and minority class examples.
plot(data.rose[, 2:3], main="Balanced data by ROSE",
     xlim=c(-6,6), ylim=c(-6,6), col=as.numeric(data.rose$cls), pch=20)
legend("topleft", c("Majority class","Minority class"), pch=20, col=1:2)

fit.rose <- glm(cls~., data=data.rose, family="binomial")
pred.rose <- predict(fit.rose, data=data.rose, type="response")
roc.curve(data.rose$cls, pred.rose, 
          main="ROC curve \n (Half circle depleted data balanced by ROSE)")
par(mfrow=c(1,1))

```
## Specifique unbalance class

```{r sepcific example train data, prompt=FALSE, echo=FALSE}
library("tidyverse")
table(hacide.train$cls)

multiclass_balance_init_train <- hacide.train %>%
    count(cls) %>%
    mutate(prop = n/sum(n))

ggplot(multiclass_balance_init_train, aes(x=cls, y=prop, fill=n)) +
  geom_bar(stat="identity") + ggtitle(label="unbalance train") + scale_fill_continuous(name = "number of elements")

paged_table(multiclass_balance_init_train)
```

```{r sepcific example test data, prompt=FALSE, echo=FALSE}
#unbalance on test set
table(hacide.test$cls)

multiclass_balance_init_test <- hacide.test %>%
    count(cls) %>%
    mutate(prop = n/sum(n))

ggplot(multiclass_balance_init_test, aes(x=cls, y=prop, fill=n)) +
  geom_bar(stat="identity") + ggtitle(label="unbalance test") + scale_fill_continuous(name = "number of elements")

paged_table(multiclass_balance_init_test)
```

```r
predictor_vars_train <- names(hacide.train[, !colnames(hacide.train) %in% c("cls")])
response_var_train <- names(hacide.train["cls"])

resampling_train <- new.ovun.sample(response_var =response_var_train ,predictor_vars =predictor_vars_train ,data=hacide.train, method = "both")
```

```{r resampling train data, prompt=FALSE, echo=FALSE}

predictor_vars_train <- names(hacide.train[, !colnames(hacide.train) %in% c("cls")])
response_var_train <- names(hacide.train["cls"])

resampling_train <- new.ovun.sample(response_var =response_var_train ,predictor_vars =predictor_vars_train ,data=hacide.train, method = "both")

multiclass_balance_train <- resampling_train$data %>%
    count(cls) %>%
    mutate(prop = n/sum(n))

ggplot(multiclass_balance_train, aes(x=cls, y=prop, fill=n)) +
  geom_bar(stat="identity") + ggtitle(label="unbalance train") + scale_fill_continuous(name = "number of elements")

paged_table(multiclass_balance_train)
```

```r
predictor_vars_test <- names(hacide.train[, !colnames(hacide.test) %in% c("cls")])
response_var_test <- names(hacide.test["cls"])

resampling_test <- new.ovun.sample(response_var =response_var_test ,predictor_vars =predictor_vars_test ,data=hacide.test, method = "both")
```


```{r resampling test data, prompt=FALSE, echo=FALSE}
predictor_vars_test <- names(hacide.train[, !colnames(hacide.test) %in% c("cls")])
response_var_test <- names(hacide.test["cls"])

resampling_test <- new.ovun.sample(response_var =response_var_test ,predictor_vars =predictor_vars_test ,data=hacide.test, method = "both")

multiclass_balance_test <- resampling_test$data %>%
    count(cls) %>%
    mutate(prop = n/sum(n))

ggplot(multiclass_balance_test, aes(x=cls, y=prop, fill=n)) +
  geom_bar(stat="identity") + ggtitle(label="unbalance test") + scale_fill_continuous(name = "number of elements")

paged_table(multiclass_balance_test)
```